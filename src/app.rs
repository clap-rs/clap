extern crate libc;

use std::collections::BTreeMap;
use std::collections::HashMap;
use std::collections::HashSet;
use std::env;
use std::path::Path;
use std::vec::IntoIter;
use std::borrow::ToOwned;

use args::{ ArgMatches, Arg, SubCommand };
use args::{FlagArg, FlagBuilder};
use args::{OptArg, OptBuilder};
use args::{PosArg, PosBuilder};

/// Used to create a representation of the program and all possible command line arguments
/// for parsing at runtime.
///
///
/// Stores a list of all posisble arguments, as well as information displayed to the user such as
/// help and versioning information.
///
/// # Example
///
/// ```no_run
/// # use clap::{App, Arg};
/// let myprog = App::new("myprog")
///                   .author("Me, me@mail.com")
///                   .version("1.0.2")
///                   .about("Explains in brief what the program does")
///                   .arg(
///                            Arg::new("in_file").index(1)
///                        // Add other possible command line argument options here...
///                    )
///                   .get_matches();
///
/// // Your pogram logic starts here...
/// ```
pub struct App<'a, 'v, 'ab, 'u, 'ar> {
    // The name displayed to the user when showing version and help/usage information
    name: String,
    // A string of author(s) if desired. Displayed when showing help/usage information
    author: Option<&'a str>,
    // The version displayed to the user
    version: Option<&'v str>,
    // A brief explaination of the program that gets displayed to the user when shown help/usage information
    about: Option<&'ab str>,
    flags: HashMap<&'ar str, FlagBuilder<'ar>>,
    opts: HashMap<&'ar str, OptBuilder<'ar>>,
    positionals_idx: BTreeMap<u8, PosBuilder<'ar>>,
    subcommands: HashMap<String, App<'a, 'v, 'ab, 'u, 'ar>>,
    needs_long_help: bool,
    needs_long_version: bool,
    needs_short_help: bool,
    needs_short_version: bool,
    needs_subcmd_help: bool,
    required: HashSet<&'ar str>,
    arg_list: HashSet<&'ar str>,
    short_list: HashSet<char>,
    long_list: HashSet<&'ar str>,
    blacklist: HashSet<&'ar str>,
    usage_str: Option<&'u str>,
    bin_name: Option<String>

}

impl<'a, 'v, 'ab, 'u, 'ar> App<'a, 'v, 'ab, 'u, 'ar>{
    /// Creates a new instance of an application requiring a name (such as the binary). Will be displayed
    /// to the user when they print version or help and usage information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// let prog = App::new("myprog")
    /// # .get_matches();
    /// ```
    pub fn new<'n>(n: &'n str) -> App<'a, 'v, 'ab, 'u, 'ar> {
        App {
            name: n.to_owned(),
            author: None,
            about: None,
            version: None,
            flags: HashMap::new(),
            opts: HashMap::new(),
            positionals_idx: BTreeMap::new(),
            subcommands: HashMap::new(),
            needs_long_version: true,
            needs_long_help: true,
            needs_short_help: true,
            needs_subcmd_help: true,
            needs_short_version: true,
            required: HashSet::new(), 
            arg_list: HashSet::new(),
            short_list: HashSet::new(),
            long_list: HashSet::new(),
            usage_str: None,
            blacklist: HashSet::new(),
            bin_name: None,
        }
    }

    /// Sets a string of author(s)
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// # let app = App::new("myprog")
    /// .author("Kevin <kbknapp@gmail.com>")
    /// # .get_matches();
    /// ```
    pub fn author(mut self, a: &'a str) -> App<'a, 'v, 'ab, 'u, 'ar> {
        self.author = Some(a);
        self
    }

    /// Sets a string briefly describing what the program does
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// # let app = App::new("myprog")
    /// .about("Does really amazing things to great people")
    /// # .get_matches();
    /// ```
    pub fn about(mut self, a: &'ab str) -> App<'a, 'v, 'ab, 'u, 'ar> {
        self.about = Some(a);
        self
    }

    /// Sets a string of the version number
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// # let app = App::new("myprog")
    /// .version("v0.1.24")
    /// # .get_matches();
    /// ```
    pub fn version(mut self, v: &'v str) -> App<'a, 'v, 'ab, 'u, 'ar>  {
        self.version = Some(v);
        self
    }
    
    /// Sets a custom usage string to over-ride the one auto-generated by `clap`
    /// 
    /// *NOTE:* You do not need to specify the "USAGE: " portion, as that will 
    /// still be applied by `clap`, you only need to specify the portion starting
    /// with the binary name. 
    /// 
    /// *NOTE:* This will not replace the entire help message, only the portion
    /// showing the usage.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// # let app = App::new("myprog")
    /// .usage("myapp [-clDas] <some_file>")
    /// # .get_matches();
    /// ```
    pub fn usage(mut self, u: &'u str) -> App<'a, 'v, 'ab, 'u, 'ar> {
        self.usage_str = Some(u);
        self
    }

    /// Adds an argument to the list of valid possibilties
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// # let app = App::new("myprog")
    /// .arg(Arg::new("config")
    ///                .short("c")
    ///             // Additional argument configuration goes here...
    /// )
    /// # .get_matches();
    /// ```
    pub fn arg<'l, 'h, 'b, 'r>(mut self, a: Arg<'ar, 'ar, 'ar, 'ar, 'ar, 'ar>) -> App<'a, 'v, 'ab, 'u, 'ar> {
        if self.arg_list.contains(a.name) {
            panic!("Argument name must be unique, \"{}\" is already in use", a.name);
        } else {
            self.arg_list.insert(a.name);
        }
        if let Some(ref s) = a.short {
            if self.short_list.contains(s) {
                panic!("Argument short must be unique, -{} is already in use", s);
            } else {
                self.short_list.insert(*s);
            }
        }
        if let Some(ref l) = a.long {
            if self.long_list.contains(l) {
                panic!("Argument long must be unique, --{} is already in use", l);
            } else {
                self.long_list.insert(l);
            }
        }
        if a.required {
            self.required.insert(a.name);
        }
        if let Some(i) = a.index {
            if a.short.is_some() || a.long.is_some() {
                panic!("Argument \"{}\" has conflicting requirements, both index() and short(), or long(), were supplied", a.name);
            }
            if self.positionals_idx.contains_key(&i) {
                panic!("Argument \"{}\" has the same index as another positional argument", a.name);
            }
            // if a.multiple {
            //     panic!("Argument \"{}\" has conflicting requirements, both index() and multiple(true) were supplied",a.name);
            // }
            if a.takes_value {
                panic!("Argument \"{}\" has conflicting requirements, both index() and takes_value(true) were supplied", a.name);
            }
            // Create the Positional Arguemnt Builder with each HashSet = None to only allocate those that require it
            let mut pb = PosBuilder {
                name: a.name,
                index: i,
                required: a.required,
                multiple: a.multiple,
                blacklist: None,
                requires: None,
                possible_vals: None,
                help: a.help,
            };
            // Check if there is anything in the blacklist (mutually excludes list) and add any values
            if let Some(ref bl) = a.blacklist {
                let mut bhs = HashSet::new();
                // without derefing n = &&str
                for n in bl { bhs.insert(*n); }
                pb.blacklist = Some(bhs);
            }
            // Check if there is anything in the requires list and add any values
            if let Some(ref r) = a.requires {
                let mut rhs = HashSet::new();
                // without derefing n = &&str
                for n in r { rhs.insert(*n); }
                pb.requires = Some(rhs);
            }
            // Check if there is anything in the possible values and add those as well
            if let Some(ref p) = a.possible_vals {
                let mut phs = HashSet::new();
                // without derefing n = &&str
                for n in p { phs.insert(*n); }
                pb.possible_vals = Some(phs);
            }
            self.positionals_idx.insert(i, pb);
        } else if a.takes_value {
            if a.short.is_none() && a.long.is_none() {
                panic!("Argument \"{}\" has take_value(true), yet neither a short() or long() were supplied", a.name);
            }
            // No need to check for .index() as that is handled above
            let mut ob = OptBuilder {
                name: a.name,
                short: a.short,
                long: a.long,
                multiple: a.multiple,
                blacklist: None,
                help: a.help,
                possible_vals: None,
                requires: None,
                required: a.required,
            };
            // Check if there is anything in the blacklist (mutually excludes list) and add any values
            if let Some(ref bl) = a.blacklist {
                let mut bhs = HashSet::new();
                // without derefing n = &&str
                for n in bl { bhs.insert(*n); }
                ob.blacklist = Some(bhs);
            }
            // Check if there is anything in the requires list and add any values
            if let Some(ref r) = a.requires {
                let mut rhs = HashSet::new();
                // without derefing n = &&str
                for n in r { rhs.insert(*n); }
                ob.requires = Some(rhs);
            }
            // Check if there is anything in the possible values and add those as well
            if let Some(ref p) = a.possible_vals {
                let mut phs = HashSet::new();
                // without derefing n = &&str
                for n in p { phs.insert(*n); }
                ob.possible_vals = Some(phs);
            }
            self.opts.insert(a.name, ob);
        } else {
            if let Some(ref l) = a.long {
                if *l == "help" {
                    self.needs_long_help = false;
                } else if *l == "version" {
                    self.needs_long_version = false;
                }
            }
            if let Some(ref s) = a.short {
                if *s == 'h' {
                    self.needs_short_help = false;
                } else if *s == 'v' {
                    self.needs_short_version = false;
                }
            }
            if a.short.is_none() && a.long.is_none() {
                panic!("Argument \"{}\" must have either a short() and/or long() supplied since no index() or takes_value() were found", a.name);
            }
            if a.required {
                panic!("Argument \"{}\" cannot be required(true) because it has no index() or takes_value(true)", a.name);
            }
            if a.possible_vals.is_some() {
                panic!("Argument \"{}\" cannot have a specific value set because it doesn't have takes_value(true) set", a.name);
            }
            // No need to check for index() or takes_value() as that is handled above

            // Flags can't be required
            // This should be unreachable...
            // if self.required.contains(a.name) {
                // self.required.remove(a.name);
            // }
            let mut fb = FlagBuilder {
                name: a.name,
                short: a.short,
                long: a.long,
                help: a.help,
                blacklist: None,
                multiple: a.multiple,
                requires: None,
            };
            // Check if there is anything in the blacklist (mutually excludes list) and add any values
            if let Some(ref bl) = a.blacklist {
                let mut bhs = HashSet::new();
                // without derefing n = &&str
                for n in bl { bhs.insert(*n); }
                fb.blacklist = Some(bhs);
            }
            // Check if there is anything in the requires list and add any values
            if let Some(ref r) = a.requires {
                let mut rhs = HashSet::new();
                // without derefing n = &&str
                for n in r { rhs.insert(*n); }
                fb.requires = Some(rhs);
            }
            self.flags.insert(a.name, fb);
        }
        self
    }

    /// Adds multiple arguments to the list of valid possibilties
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg};
    /// # let app = App::new("myprog")
    /// .args( vec![Arg::new("config").short("c"),
    ///                Arg::new("debug").short("d")])
    /// # .get_matches();
    /// ```
    pub fn args(mut self, args: Vec<Arg<'ar, 'ar, 'ar, 'ar, 'ar, 'ar>>) -> App<'a, 'v, 'ab, 'u, 'ar> {
        for arg in args.into_iter() {
            self = self.arg(arg);
        }
        self
    }

    /// Adds a subcommand to the list of valid possibilties. Subcommands
    /// are effectively sub apps, because they can contain their own arguments
    /// and subcommands. They also function just like apps, in that they get their
    /// own auto generated help and version switches.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg, SubCommand};
    /// # let app = App::new("myprog")
    /// .subcommand(SubCommand::new("config")
    ///                .about("Controls configuration features")
    ///                .arg(Arg::new("config_file")
    ///                        .index(1)
    ///                        .help("Configuration file to use")))
    ///             // Additional subcommand configuration goes here, such as arguments...
    /// # .get_matches();
    /// ```
    pub fn subcommand(mut self, subcmd: App<'a, 'v, 'ab, 'u, 'ar>) -> App<'a, 'v, 'ab, 'u, 'ar> {
        if subcmd.name == "help" { self.needs_subcmd_help = false; }
        self.subcommands.insert(subcmd.name.clone(), subcmd);
        self
    }

    /// Adds multiple subcommands to the list of valid possibilties
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use clap::{App, Arg, SubCommand};
    /// # let app = App::new("myprog")
    /// .subcommands( vec![
    ///        SubCommand::new("config").about("Controls configuration functionality")
    ///                                 .arg(Arg::new("config_file").index(1)),
    ///        SubCommand::new("debug").about("Controls debug functionality")])
    /// # .get_matches();
    /// ```
    pub fn subcommands(mut self, subcmds: Vec<App<'a, 'v, 'ab, 'u, 'ar>>) -> App<'a, 'v, 'ab, 'u, 'ar> {
        for subcmd in subcmds.into_iter() {
            self = self.subcommand(subcmd);
        }
        self
    }

    fn print_usage(&self, more_info: bool) {
        println!("USAGE:");
        if let Some(u) = self.usage_str {
            println!("    {}",u);
        } else {
            let flags = !self.flags.is_empty();
            let pos = !self.positionals_idx.is_empty();
            let opts = !self.opts.is_empty();
            let subcmds = !self.subcommands.is_empty();
            let mut num_req_pos = 0;
            let req_pos = self.positionals_idx.values().filter_map(|ref x| if x.required || self.required.contains(x.name) { 
                num_req_pos += 1;
                if x.multiple {
                    Some(format!("<{}>...", x.name))
                } else {
                    Some(format!("<{}>", x.name))
                } 
            } else {
                None
            })
                                                       .fold(String::new(), |acc, ref name| acc + &format!("{} ", name)[..]);
            let mut num_req_opts = 0;
            let req_opts = self.opts.values().filter_map(|x| if x.required || self.required.contains(x.name) {
                num_req_opts += 1;
                Some(x)
            }else {
                None
            })
                                             .fold(String::new(), |acc, ref o| acc + &format!("-{}{} ",if let Some(l) = o.long {
                                                                                                     format!("-{}=", l)
                                                                                                   } else {
                                                                                                       format!("{} ",o.short.unwrap())
                                                                                                   },o.name));

            print!("    {} {} {} {} {}", self.bin_name.clone().unwrap_or(self.name.clone()),
                if flags {"[FLAGS]"} else {""},
                if opts {
                    if num_req_opts != self.opts.len() && !req_opts.is_empty() { 
                        format!("[OPTIONS] {}", &req_opts[..])
                    } else if req_opts.is_empty() { 
                        "[OPTIONS]".to_owned()
                    } else {
                        req_opts 
                    } 
                } else { "".to_owned() },
                if pos {
                    if num_req_pos != self.positionals_idx.len() && !req_pos.is_empty() { 
                        format!("[POSITIONAL] {}", &req_pos[..])
                    } else if req_pos.is_empty() { 
                        "[POSITIONAL]".to_owned() 
                    } else {
                        req_pos 
                    } 
                } else {"".to_owned()},
                if subcmds {"[SUBCOMMANDS]"} else {""});
        }

        if more_info {
            println!("\nFor more information try --help");
        }
    }

    fn print_help(&self) {
        self.print_version(false);
        let flags = !self.flags.is_empty();
        let pos = !self.positionals_idx.is_empty();
        let opts = !self.opts.is_empty();
        let subcmds = !self.subcommands.is_empty();

        let mut longest_flag = 0;
        for fl in self.flags
            .values()
            .filter_map(|ref f| f.long)
            .map(|ref l| l.len() + 2) {
            if fl > longest_flag { longest_flag = fl; }
        }
        let mut longest_opt= 0;
        for ol in self.opts
            .values()
            .filter_map(|ref f| if f.long.is_some() {let mult = if f.multiple { 3 } else { 0 }; Some(f.long.unwrap().len() + mult + f.name.len() + 3)}else {None}) {
            if ol > longest_opt {longest_opt = ol;}
        }
        let mut longest_pos = 0;
        for pl in self.positionals_idx
            .values()
            .map(|ref f| if f.multiple { f.name.len() + 3 } else { f.name.len() } ) {
            if pl > longest_pos {longest_pos = pl;}
        }
        let mut longest_sc = 0;
        for scl in self.subcommands
            .values()
            .map(|ref f| f.name.len() ) {
            if scl > longest_sc {longest_sc = scl;}
        }
        
        if let Some(author) = self.author {
            println!("{}", author);
        }
        if let Some(about) = self.about {
            println!("{}", about);
        }
        println!("");
        self.print_usage(false);
        if flags || opts || pos || subcmds {
            println!("");
        }

        let tab = "    ";
        if flags {
            println!("");
            println!("FLAGS:");
            for v in self.flags.values() {
                println!("{}{}{}{}",tab,
                        if let Some(s) = v.short{format!("-{}",s)}else{tab.to_owned()},
                        if let Some(l) = v.long {
                            format!("{}--{}{}", 
                                if v.short.is_some() { ", " } else {""}, 
                                l, 
                                // +2 accounts for the ', ' +4 for tab = 6
                                self.get_spaces((longest_flag + 4) - (v.long.unwrap().len() + 2)))
                        } else {
                            // 6 is tab (4) + -- (2)
                            self.get_spaces(longest_flag+6).to_owned()
                        },
                        v.help.unwrap_or(tab) );
            }
        }
        if opts {
            println!("");
            println!("OPTIONS:");
            for v in self.opts.values() {
                // if it supports multiple we add '...' i.e. 3 to the name length
                let mult = if v.multiple { 3 } else { 0 };
                // let long_len = if v.long.is_some() { v.long.unwrap().len() + 3}else{0};
                // let mut needs_tab = false;
                println!("{}{}{}{}{}{}",tab,
                        if let Some(s) = v.short{format!("-{}",s)}else{tab.to_owned()},
                        if let Some(l) = v.long {
                            format!("{}--{}=", 
                                if v.short.is_some() {", "} else {""},l)
                        } else {
                            " ".to_owned()
                        },
                        format!("{}{}", v.name, if v.multiple{"..."} else {""}),
                        if v.long.is_some() {
                            self.get_spaces((longest_opt + 4) - (v.long.unwrap().len() + v.name.len() + 2 + mult))
                        } else {
                            // 7 is '--=' (3) + tab (4)
                            self.get_spaces((longest_opt + 6) - (v.name.len() + mult))
                        },
                        if let Some(h) = v.help {
                            format!("{}{}", h,
                                if let Some(ref pv) = v.possible_vals {
                                    format!(" [values:{}]", pv.iter().fold(String::new(), |acc, name| acc + &format!(" {}",name)[..] ))
                                }else{
                                    "".to_owned()
                                })
                        } else {
                            tab.to_owned()
                        } );
            }
        }
        if pos {
            println!("");
            println!("POSITIONAL ARGUMENTS:");
            for v in self.positionals_idx.values() {
                let mult = if v.multiple { 3 } else { 0 };
                println!("{}{}{}{}",tab,
                    if v.multiple {format!("{}...",v.name)} else {v.name.to_owned()},
                    self.get_spaces((longest_pos + 4) - (v.name.len() + mult)),
                    if let Some(h) = v.help {
                        format!("{}{}",
                            h,
                            if let Some(ref pv) = v.possible_vals {
                                format!(" [values:{}]", pv.iter().fold(String::new(), |acc, name| acc + &format!(" {}",name)[..] ))
                            }else{"".to_owned()})
                    } else {
                        tab.to_owned()
                    } );
            }
        }
        if subcmds {
            println!("");
            println!("SUBCOMMANDS:");
            for sc in self.subcommands.values() {
                println!("{}{}{}{}",tab,
                 sc.name,
                 self.get_spaces((longest_sc + 4) - (sc.name.len())),
                 if let Some(a) = sc.about {a} else {tab} );
            }
        }

        self.exit();
    }

    #[inline(always)]
    fn get_spaces(&self, num: usize) -> &'static str {
        match num {
            0 => "",
            1 => " ",
            2 => "  ",
            3 => "   ",
            4 => "    ",
            5 => "     ",
            6 => "      ",
            7 => "       ",
            8 => "        ",
            9 => "         ",
            10=> "          ",
            11=> "           ",
            12=> "            ",
            13=> "             ",
            14=> "              ",
            15=> "               ",
            16=> "                ",
            17=> "                 ",
            18=> "                  ",
            19=> "                   ",
            20=> "                    ",
            21=> "                     ",
            22=> "                      ",
            23=> "                       ",
            24=> "                        ",
            25|_=> "                         "
        }
    }
    fn print_version(&self, quit: bool) {
        // Print the binary name if existing, but replace all spaces with hyphens in case we're
        // dealing with subcommands i.e. git mv is translated to git-mv
        println!("{} {}", &self.bin_name.clone().unwrap_or(self.name.clone())[..].replace(" ", "-"), self.version.unwrap_or("") );
        if quit { self.exit(); }
    }

    fn exit(&self) {
        unsafe { libc::exit(0); }
    }

    fn report_error(&self, msg: String, usage: bool, quit: bool) {
        println!("{}", msg);
        if usage { self.print_usage(true); }
        if quit { env::set_exit_status(1); self.exit(); }
    }

    pub fn get_matches(mut self) -> ArgMatches<'ar> {
        self.verify_positionals();
        for sc in self.subcommands.values() {
            sc.verify_positionals();
        }

        let mut matches = ArgMatches::new();

        let args = env::args().collect::<Vec<_>>();    
        let mut it = args.into_iter();
        if let Some(name) = it.next() {
            let p = Path::new(&name[..]);
            if let Some(f) = p.file_name() {
                if let Ok(s) = f.to_os_string().into_string() {
                    self.bin_name = Some(s);
                }
            }
        }
        self.get_matches_from(&mut matches, &mut it );

        matches
    }

    fn verify_positionals(&self) {
        // Because you must wait until all arguments have been supplied, this is the first chance
        // to make assertions on positional argument indexes
        // 
        // Firt we verify that the index highest supplied index, is equal to the number of
        // positional arguments to verify there are no gaps (i.e. supplying an index of 1 and 3
        // but no 2)
        //
        // Next we verify that only the highest index has a .multiple(true) (if any)
        if let Some((idx, ref p)) = self.positionals_idx.iter().rev().next() {
            if *idx as usize != self.positionals_idx.len() {
                panic!("Found positional argument \"{}\" who's index is {} but there are only {} positional arguments defined", p.name, idx, self.positionals_idx.len());
            }
        }
        if let Some(ref p) = self.positionals_idx.values()
                                                 .filter(|ref a| a.multiple)
                                                 .filter(|ref a| a.index as usize != self.positionals_idx.len())
                                                 .next() {
            panic!("Found positional argument \"{}\" which accepts multiple values but it's not the last positional argument (i.e. others have a higher index)", 
                    p.name);
        }
    }

    fn get_matches_from(&mut self, matches: &mut ArgMatches<'ar>, it: &mut IntoIter<String>) {
        self.create_help_and_version();

        let mut pos_only = false;
        let mut subcmd_name: Option<String> = None;
        let mut needs_val_of: Option<&str> = None; 
        let mut pos_counter = 1;
        while let Some(arg) = it.next() {
            let arg_slice = &arg[..];
            let mut skip = false;
            if !pos_only {
                if let Some(nvo) = needs_val_of {
                    if let Some(ref opt) = self.opts.get(nvo) {
                        if let Some(ref p_vals) = opt.possible_vals {
                            if !p_vals.is_empty() {
                                if !p_vals.contains(arg_slice) {
                                    self.report_error(format!("\"{}\" isn't a valid value for {}{}", 
                                                                arg_slice, 
                                                                if opt.long.is_some() {
                                                                    format!("--{}",opt.long.unwrap())
                                                                }else{
                                                                    format!("-{}", opt.short.unwrap())
                                                                },
                                                                format!("\n    [valid values:{}]", p_vals.iter().fold(String::new(), |acc, name| acc + &format!(" {}",name)[..] )) ), true, true);
                                }
                            }
                        }
                        if let Some(ref mut o) = matches.opts.get_mut(opt.name) {
                            o.values.push(arg.clone());
                            // if it's multiple the occurrences are increased when originall found
                            o.occurrences = if opt.multiple { o.occurrences + 1 } else { 1 };
                        }
                        
                        skip = true;
                    }
                }
            }
            if skip {
                needs_val_of = None;
                continue;
            }
            if arg_slice.starts_with("--") && !pos_only {
                if arg_slice.len() == 2 {
                    pos_only = true;
                    continue;
                }
                // Single flag, or option long version
                needs_val_of = self.parse_long_arg(matches, &arg);
            } else if arg_slice.starts_with("-") && arg_slice.len() != 1 && ! pos_only {
                needs_val_of = self.parse_short_arg(matches, &arg);
            } else {
                // Positional or Subcommand
                if self.subcommands.contains_key(&arg) {
                    if arg_slice == "help" {
                        self.print_help();
                    }
                    subcmd_name = Some(arg.clone());
                    break;
                }

                if self.positionals_idx.is_empty() {
                    self.report_error(
                        format!("Found positional argument {}, but {} doesn't accept any", arg, self.name),
                        true, true);
                }
                if let Some(p) = self.positionals_idx.get(&pos_counter) {
                    if self.blacklist.contains(p.name) {
                        self.report_error(format!("The argument \"{}\" is mutually exclusive with one or more other arguments", arg),
                            true, true);
                    }

                    if let Some(ref p_vals) = p.possible_vals {
                        if !p_vals.is_empty() {
                            if !p_vals.contains(arg_slice) {
                                self.report_error(format!("\"{}\" isn't a valid value for {}{}", 
                                    arg_slice, 
                                    p.name,
                                    format!("\n    [valid values:{}]", p_vals.iter().fold(String::new(), |acc, name| acc + &format!(" {}",name)[..] )) ), true, true);
                            }
                        }
                    }
                    // Have we made the update yet?
                    let mut done = false;
                    if p.multiple {
                        // Check if it's already existing and update if so...
                        if let Some(ref mut pa) = matches.positionals.get_mut(p.name) {
                            done = true;
                            pa.occurrences += 1;
                            pa.values.push(arg.clone());
                        }
                    } else {
                        // Only increment the positional counter if it doesn't allow multiples
                        pos_counter += 1;
                    }
                    // Was an update made, or is this the first occurrence?
                    if !done {
                        matches.positionals.insert(p.name, PosArg{
                            name: p.name.to_owned(),
                            occurrences: 1,
                            values: vec![arg.clone()],
                        });
                    }

                    if let Some(ref bl) = p.blacklist {
                        for name in bl {
                            self.blacklist.insert(name);
                            self.required.remove(name);
                        }
                    }
                    if self.required.contains(p.name) {
                        self.required.remove(p.name);
                    }
                    if let Some(ref reqs) = p.requires {
                        // Add all required args which aren't already found in matches to the
                        // final required list
                        for n in reqs {
                            if matches.positionals.contains_key(n) {continue;}
                            if matches.opts.contains_key(n) {continue;}
                            if matches.flags.contains_key(n) {continue;}

                            self.required.insert(n);
                        }
                    }
                } else {
                    self.report_error(format!("Positional argument \"{}\" was found, but {} wasn't expecting any", arg, self.name), true, true);
                }
            }
        }
        match needs_val_of {
            Some(ref a) => {
                self.report_error(
                    format!("Argument \"{}\" requires a value but none was supplied", a),
                    true, true);
            }
            _ => {}
        }
        if !self.required.is_empty() {
            self.report_error("One or more required arguments were not supplied".to_owned(),
                    true, true);
        }

        self.validate_blacklist(&matches);

        if let Some(sc_name) = subcmd_name {
            if let Some(ref mut sc) = self.subcommands.get_mut(&sc_name) {
                let mut new_matches = ArgMatches::new();
                // bin_name should be parent's bin_name + the sc's name seperated by a space
                sc.bin_name = Some(format!("{}{}{}", self.bin_name.clone().unwrap_or("".to_owned()),if self.bin_name.is_some() {" "} else {""}, sc.name.clone()));
                sc.get_matches_from(&mut new_matches, it);
                matches.subcommand = Some(Box::new(SubCommand{
                    name: sc.name.clone(),
                    matches: new_matches}));
            }
        }    
    }

    fn create_help_and_version(&mut self) {
        if self.needs_long_help {
            self.flags.insert("clap_help", FlagBuilder {
                name: "clap_help",
                short: if self.needs_short_help { Some('h') } else { None },
                long: Some("help"),
                help: Some("Prints this message"),
                blacklist: None,
                multiple: false,
                requires: None,
            });
        }
        if self.needs_long_version {
            self.flags.insert("clap_version", FlagBuilder {
                name: "clap_version",
                short: if self.needs_short_help { Some('v') } else { None },
                long: Some("version"),
                help: Some("Prints version information"),
                blacklist: None,
                multiple: false,
                requires: None,
            });
        }
        if self.needs_subcmd_help && !self.subcommands.is_empty() {
            self.subcommands.insert("help".to_owned(), App::new("help").about("Prints this message"));
        }
    }

    fn check_for_help_and_version(&self, arg: char) {
        if arg == 'h' && self.needs_short_help {
            self.print_help();
        } else if arg == 'v' && self.needs_short_version {
            self.print_version(true);
        }
    }

    fn parse_long_arg(&mut self, matches: &mut ArgMatches<'ar> ,full_arg: &String) -> Option<&'ar str> {
        let mut arg = full_arg.trim_left_matches(|c| c == '-');

        if arg == "help" && self.needs_long_help {
            self.print_help();
        } else if arg == "version" && self.needs_long_version {
            self.print_version(true);
        }

        let mut arg_val: Option<String> = None;

        if arg.contains("=") {
            let arg_vec: Vec<&str> = arg.split("=").collect();
            arg = arg_vec[0];
            // prevents "--config= value" typo
            if arg_vec[1].len() == 0 {
                self.report_error(format!("Argument --{} requires a value, but none was supplied", arg), true, true);
            }
            arg_val = Some(arg_vec[1].to_owned());
        } 

        if let Some(v) = self.opts.values().filter(|&v| v.long.is_some()).filter(|&v| v.long.unwrap() == arg).nth(0) {
            // Ensure this option isn't on the master mutually excludes list
            if self.blacklist.contains(v.name) {
                self.report_error(format!("The argument --{} is mutually exclusive with one or more other arguments", arg),
                    true, true);
            }

            if matches.opts.contains_key(v.name) {
                if !v.multiple {
                    self.report_error(format!("Argument --{} was supplied more than once, but does not support multiple values", arg), true, true);
                }
                if let Some(ref p_vals) = v.possible_vals {
                    if let Some(ref av) = arg_val {
                        if !p_vals.contains(&av[..]) {
                            self.report_error(format!("\"{}\" isn't a valid value for {}{}", 
                                                        arg_val.clone().unwrap_or(arg.to_owned()), 
                                                        if v.long.is_some() {
                                                            format!("--{}", v.long.unwrap())
                                                        }else{
                                                            format!("-{}", v.short.unwrap())
                                                        },
                                                        format!("\n    [valid values:{}]", p_vals.iter().fold(String::new(), |acc, name| acc + &format!(" {}",name)[..] )) ), true, true);
                        }
                    }
                }
                if arg_val.is_some() {
                    if let Some(ref mut o) = matches.opts.get_mut(v.name) {
                        o.occurrences += 1;
                        o.values.push(arg_val.clone().unwrap());
                    }
                }
            } else {
                matches.opts.insert(v.name, OptArg{
                    name: v.name.to_owned(),
                    occurrences: if arg_val.is_some() { 1 } else { 0 },
                    values: if arg_val.is_some() { vec![arg_val.clone().unwrap()]} else {vec![]} 
                });
            }
            
            if let Some(ref bl) = v.blacklist {
                for name in bl {
                    self.blacklist.insert(name);
                    self.required.remove(name);
                }
            }
            if self.required.contains(v.name) {
                self.required.remove(v.name);
            }
            if let Some(ref reqs) = v.requires {
                // Add all required args which aren't already found in matches to the
                // final required list
                for n in reqs {
                    if matches.opts.contains_key(n) { continue; }
                    if matches.flags.contains_key(n) { continue; }
                    if matches.positionals.contains_key(n) { continue; }

                    self.required.insert(n);
                }
            } 
            match arg_val {
                None => { return Some(v.name); },
                _    => { return None; }
            }
        } 

        if let Some(v) = self.flags.values().filter(|&v| v.long.is_some()).filter(|&v| v.long.unwrap() == arg).nth(0) {
            // Ensure this flag isn't on the mutually excludes list
            if self.blacklist.contains(v.name) {
                self.report_error(format!("The argument --{} is mutually exclusive with one or more other arguments", arg),
                    true, true);
            }
            
            // Make sure this isn't one being added multiple times if it doesn't suppor it
            if matches.flags.contains_key(v.name) && !v.multiple {
                self.report_error(format!("Argument --{} was supplied more than once, but does not support multiple values", arg), true, true);
            }

            let mut 
            done = false;
            if let Some(ref mut f) = matches.flags.get_mut(v.name) {
                done = true;
                f.occurrences = if v.multiple { f.occurrences + 1 } else { 1 };
            }
            if !done { 
                matches.flags.insert(v.name, FlagArg{
                    name: v.name.to_owned(),
                    occurrences: 1
                });
            }

            // If this flag was requierd, remove it
            // .. even though Flags shouldn't be required
            if self.required.contains(v.name) {
                self.required.remove(v.name);
            }

            // Add all of this flags "mutually excludes" list to the master list
            if let Some(ref bl) = v.blacklist {
                for name in bl {
                    self.blacklist.insert(name);
                    self.required.remove(name);
                }
            }

            // Add all required args which aren't already found in matches to the master list
            if let Some(ref reqs) = v.requires {
                for n in reqs {
                    if matches.flags.contains_key(n) { continue; }
                    if matches.opts.contains_key(n) { continue; }
                    if matches.positionals.contains_key(n) { continue; }

                    self.required.insert(n);
                }
            }
            return None;
        }

        // Shouldn't reach here
        self.report_error(format!("Argument --{} isn't valid", arg), true, true);
        unreachable!();
    }

    fn parse_short_arg(&mut self, matches: &mut ArgMatches<'ar> ,full_arg: &String) -> Option<&'ar str> {
        let arg = &full_arg[..].trim_left_matches(|c| c == '-');
        if arg.len() > 1 { 
            // Multiple flags using short i.e. -bgHlS
            for c in arg.chars() {
                self.check_for_help_and_version(c);
                if !self.parse_single_short_flag(matches, c) { 
                    self.report_error(format!("Argument -{} isn't valid",arg), true, true);
                }
            }
            return None;
        } 
        // Short flag or opt
        let arg_c = arg.chars().nth(0).unwrap();

        // Ensure the arg in question isn't a help or version flag
        self.check_for_help_and_version(arg_c);

        // Check for a matching flag, and return none if found
        if self.parse_single_short_flag(matches, arg_c) { return None; }
        
        // Check for matching short in options, and return the name
        // (only ones with shorts, of course)
        if let Some(v) = self.opts.values().filter(|&v| v.short.is_some()).filter(|&v| v.short.unwrap() == arg_c).nth(0) {
            // Ensure this option isn't on the master mutually excludes list
            if self.blacklist.contains(v.name) {
                self.report_error(format!("The argument --{} is mutually exclusive with one or more other arguments", arg),
                    true, true);
            }

            if matches.opts.contains_key(v.name) {
                if !v.multiple {
                    self.report_error(format!("Argument -{} was supplied more than once, but does not support multiple values", arg), true, true);
                }
            } else {
                matches.opts.insert(v.name, OptArg{
                    name: v.name.to_owned(),
                    // occurrences will be incremented on getting a value
                    occurrences: 0,
                    values: vec![]
                });
            }
            if let Some(ref bl) = v.blacklist {
                for name in bl {
                    self.blacklist.insert(name);
                    self.required.remove(name);
                }
            }
            if self.required.contains(v.name) {
                self.required.remove(v.name);
            }
            if let Some(ref reqs) = v.requires {
                // Add all required args which aren't already found in matches to the
                // final required list
                for n in reqs {
                    if matches.opts.contains_key(n) { continue; }
                    if matches.flags.contains_key(n) { continue; }
                    if matches.positionals.contains_key(n) { continue; }

                    self.required.insert(n);
                }
            } 
            return Some(v.name)
        } 

        // Didn't match a flag or option, must be invalid
        self.report_error( format!("Argument -{} isn't valid",arg_c), true, true);

        unreachable!();
    }

    fn parse_single_short_flag(&mut self, matches: &mut ArgMatches<'ar>, arg: char) -> bool {
        for v in self.flags.values().filter(|&v| v.short.is_some()).filter(|&v| v.short.unwrap() == arg) {
            // Ensure this flag isn't on the mutually excludes list
            if self.blacklist.contains(v.name) {
                self.report_error(format!("The argument -{} is mutually exclusive with one or more other arguments", arg),
                    true, true);
            }

            // Make sure this isn't one being added multiple times if it doesn't suppor it
            if matches.flags.contains_key(v.name) && !v.multiple {
                self.report_error(format!("Argument -{} was supplied more than once, but does not support multiple values", arg), true, true);
            }

            let mut done = false;
            if let Some(ref mut f) = matches.flags.get_mut(v.name) {
                done = true;
                f.occurrences = if v.multiple { f.occurrences + 1 } else { 1 };
            } 
            if !done {
                matches.flags.insert(v.name, FlagArg{
                    name: v.name.to_owned(),
                    occurrences: 1
                });
            }

            // If this flag was requierd, remove it
            // .. even though Flags shouldn't be required
            if self.required.contains(v.name) {
                self.required.remove(v.name);
            }

            // Add all of this flags "mutually excludes" list to the master list
            if let Some(ref bl) = v.blacklist {
                for name in bl {
                    self.blacklist.insert(name);
                    self.required.remove(name);
                }
            }

            // Add all required args which aren't already found in matches to the master list
            if let Some(ref reqs) = v.requires {
                for n in reqs {
                    if matches.flags.contains_key(n) { continue; }
                    if matches.opts.contains_key(n) { continue; }
                    if matches.positionals.contains_key(n) { continue; }

                    self.required.insert(n);
                }
            }
            return true;
        }
        false
    }

    fn validate_blacklist(&self, matches: &ArgMatches<'ar>) {
        for name in self.blacklist.iter() {
            if matches.flags.contains_key(name) {
                self.report_error(format!("The argument {} is mutually exclusive with one or more other arguments",
                    if let Some(s) = self.flags.get(name).unwrap().short {
                        format!("-{}", s)
                    } else if let Some(l) = self.flags.get(name).unwrap().long {
                        format!("--{}", l)
                    } else {
                        format!("\"{}\"", name)
                    }), true, true);
            }
            if matches.opts.contains_key(name) {
                self.report_error(format!("The argument {} is mutually exclusive with one or more other arguments",
                    if let Some(s) = self.opts.get(name).unwrap().short {
                        format!("-{}", s)
                    } else if let Some(l) = self.opts.get(name).unwrap().long {
                        format!("--{}", l)
                    } else {
                        format!("\"{}\"", name)
                    }), true, true);
            }
            if matches.positionals.contains_key(name) {
                self.report_error(format!("The argument \"{}\" is mutually exclusive with one or more other arguments",name),
                    false, true);
            }
        }
    }

}
